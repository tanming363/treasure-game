import { TmplAstRecursiveVisitor } from '@angular/compiler';
import { Component, OnInit } from '@angular/core';
import { User } from '../model/user.model'
import { UserService } from '../service/user.service';
import { Cell } from './treasure.model';
import { Vec2 } from './vec2';
@Component({
        selector: 'app-game',
        templateUrl: './game.component.html',
        styleUrls: ['./game.component.scss']
})
export class GameComponent implements OnInit {
        constructor(private userService: UserService) { }
        users: User[] = []
        ngOnInit() {
                this.printBaard();
                this.getUserName()
        }
        submitted: boolean = false;
        items = [];

        scores = [];
        count: number = 0;
        total: number = 0;
        score: number = 0;
        turn: number = 0;
        numTresure: number = 1;
        success: boolean = false;
        name: string;

        private generateRandomCoords(): Vec2 {
                let randomX: any = Math.floor(Math.random() * 6);
                let randomY: any = Math.floor(Math.random() * 6);
                return new Vec2(randomX, randomY);
        }

        printBaard() {
                let board: Cell[] = [];
                let treasures: Cell[] = [];
                let cells3: Cell[] = [];
                let cells2: Cell[] = [];
                let cells1: Cell[] = [];

                //First T
                treasures.push(
                        new Cell(this.generateRandomCoords(), "T")
                );

                //Second and Third T
                for (let i = 0; i < 2; i++) {
                        let treasureCandidate: Cell;
                        do {
                                treasureCandidate = new Cell(this.generateRandomCoords(), "T")
                        }
                        while (treasures[0].checkConstraint(treasureCandidate))
                        treasures.push(treasureCandidate);
                }

                treasures.forEach((treasure: Cell) => {
                        const threes: Cell[] = [];
                        threes.push(
                                new Cell(new Vec2(
                                        treasure.coordinates.x,
                                        treasure.coordinates.y - 1
                                ), "3")
                        )

                        threes.push(
                                new Cell(new Vec2(
                                        treasure.coordinates.x,
                                        treasure.coordinates.y + 1
                                ), "3")
                        )

                        threes.push(
                                new Cell(new Vec2(
                                        treasure.coordinates.x - 1,
                                        treasure.coordinates.y
                                ), "3")
                        )

                        threes.push(
                                new Cell(new Vec2(
                                        treasure.coordinates.x,
                                        treasure.coordinates.y + 1
                                ), "3")
                        )

                        cells3.concat(threes);
                });

                treasures.forEach((treasure: Cell) => {
                        const twos: Cell[] = [];

                        twos.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x - 1, treasure.coordinates.y - 1),
                                        "2"
                                )
                        )

                        twos.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x + 1, treasure.coordinates.y + 1),
                                        "2"
                                )
                        )

                        twos.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x - 1, treasure.coordinates.y + 1),
                                        "2"
                                )
                        )

                        twos.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x + 1, treasure.coordinates.y - 1),
                                        "2"
                                )
                        )
                        cells2.concat(twos);
                });
                treasures.forEach((treasure: Cell) => {
                        const ones: Cell[] = [];
                        ones.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x - 1, treasure.coordinates.y - 1),
                                        "1"
                                )
                        )

                        ones.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x + 1, treasure.coordinates.y + 1),
                                        "1"
                                )
                        )

                        ones.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x - 1, treasure.coordinates.y + 1),
                                        "1"
                                )
                        )

                        ones.push(
                                new Cell(
                                        new Vec2(treasure.coordinates.x + 1, treasure.coordinates.y - 1),
                                        "1"
                                )
                        )
                        cells1.concat(ones);
                });

                cells2 = cells2.filter((cell: Cell) => {
                        return cell.checkCollsion(treasures[0]) || cell.checkCollsion(treasures[1]) || cell.checkCollsion(treasures[2])
                });
                board
                        .concat(treasures)
                        .concat(cells3)
                        .concat(cells2)
                        .concat(cells1)


                // for (let i = 1; i < 26; i++) {
                //   let random: any = Math.floor(Math.random() * 3) + 1;
                //   if (random === 1 && this.numTresure < 4) {
                //     this.numTresure += 1;
                //     const treasure = "T";
                //     random = treasure;
                //   }
                //   this.items.push(random);
                // };
        }

        show(event) {
                this.count += 1;
                if (this.count < 4) {
                        if (event.target.children[0].innerText === "T") {
                                event.target.classList.add("yellow");
                                this.score += 1;
                                if (this.score === 3) {
                                        this.success = true;
                                        event.target.children[0].classList.remove("d-none");
                                        event.target.setAttribute("disabled", "");
                                        document.querySelector(".board").innerHTML +=
                                                `<button class="btn p-0"></button>`;
                                }
                        }
                        event.target.children[0].classList.remove("d-none");
                        event.target.setAttribute("disabled", "");

                        if (this.count === 3) {
                                this.count = 0;
                                this.count += 1;
                                this.scores.push(this.count)
                                console.log("NEW COUNT", this.count);
                        }
                }
        }
        userModel = new User("")

        onSubmit() {
                this.submitted = true;
                this.userService.postPlayerName(this.userModel).subscribe(
                        data => console.log("Success", data),
                        error => console.log("Error", error),
                )
        }

        getUserName() {
                this.userService.getPlayerName().subscribe((res) => {
                        this.userService.users = res;
                });
        }
}